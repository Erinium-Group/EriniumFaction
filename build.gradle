buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'com.hierynomus:sshj:0.38.0'
    }
}

plugins {
    id 'java-library'
    id 'maven-publish'
    id 'idea'
    id 'net.neoforged.moddev' version '2.0.115'
}

import net.schmizz.sshj.SSHClient
import net.schmizz.sshj.sftp.SFTPClient
import net.schmizz.sshj.transport.verification.PromiscuousVerifier


version = mod_version
group = mod_group_id

repositories {
    mavenLocal()
}

base {
    archivesName = mod_id
}

java.toolchain.languageVersion = JavaLanguageVersion.of(21)

neoForge {
    // Specify the version of NeoForge to use.
    version = project.neo_version

    parchment {
        mappingsVersion = project.parchment_mappings_version
        minecraftVersion = project.parchment_minecraft_version
    }

    // This line is optional. Access Transformers are automatically detected
    // accessTransformers.add('src/main/resources/META-INF/accesstransformer.cfg')

    // Default run configurations.
    // These can be tweaked, removed, or duplicated as needed.
    runs {
        client {
            client()

            // Comma-separated list of namespaces to load gametests from. Empty = all namespaces.
            systemProperty 'neoforge.enabledGameTestNamespaces', project.mod_id
        }

        server {
            server()
            programArgument '--nogui'
            systemProperty 'neoforge.enabledGameTestNamespaces', project.mod_id
        }

        // This run config launches GameTestServer and runs all registered gametests, then exits.
        // By default, the server will crash when no gametests are provided.
        // The gametest system is also enabled by default for other run configs under the /test command.
        gameTestServer {
            type = "gameTestServer"
            systemProperty 'neoforge.enabledGameTestNamespaces', project.mod_id
        }

        data {
            data()

            // example of overriding the workingDirectory set in configureEach above, uncomment if you want to use it
            // gameDirectory = project.file('run-data')

            // Specify the modid for data generation, where to output the resulting resource, and where to look for existing resources.
            programArguments.addAll '--mod', project.mod_id, '--all', '--output', file('src/generated/resources/').getAbsolutePath(), '--existing', file('src/main/resources/').getAbsolutePath()
        }

        // applies to all the run configs above
        configureEach {
            // Recommended logging data for a userdev environment
            // The markers can be added/remove as needed separated by commas.
            // "SCAN": For mods scan.
            // "REGISTRIES": For firing of registry events.
            // "REGISTRYDUMP": For getting the contents of all registries.
            systemProperty 'forge.logging.markers', 'REGISTRIES'

            // Recommended logging level for the console
            // You can set various levels here.
            // Please read: https://stackoverflow.com/questions/2031163/when-to-use-the-different-log-levels
            logLevel = org.slf4j.event.Level.DEBUG
        }
    }

    mods {
        // define mod <-> source bindings
        // these are used to tell the game which sources are for which mod
        // mostly optional in a single mod project
        // but multi mod projects should define one per mod
        "${mod_id}" {
            sourceSet(sourceSets.main)
        }
    }
}

// Include resources generated by data generators.
sourceSets.main.resources { srcDir 'src/generated/resources' }


dependencies {
    // Example mod dependency with JEI
    // The JEI API is declared for compile time use, while the full JEI artifact is used at runtime
    // compileOnly "mezz.jei:jei-${mc_version}-common-api:${jei_version}"
    // compileOnly "mezz.jei:jei-${mc_version}-forge-api:${jei_version}"
    // runtimeOnly "mezz.jei:jei-${mc_version}-forge:${jei_version}"

    // Example mod dependency using a mod jar from ./libs with a flat dir repository
    // This maps to ./libs/coolmod-${mc_version}-${coolmod_version}.jar
    // The group id is ignored when searching -- in this case, it is "blank"
    // implementation "blank:coolmod-${mc_version}:${coolmod_version}"

    // Example mod dependency using a file as dependency
    // implementation files("libs/coolmod-${mc_version}-${coolmod_version}.jar")

    // Example project dependency using a sister or child project:
    // implementation project(":myproject")

    // For more info:
    // http://www.gradle.org/docs/current/userguide/artifact_dependencies_tutorial.html
    // http://www.gradle.org/docs/current/userguide/dependency_management.html
}

// This blsock of code expands all declared replace properties in the specified resource targets.
// A missing property will result in an error. Properties are expanded using ${} Groovy notation.
var generateModMetadata = tasks.register("generateModMetadata", ProcessResources) {
    var replaceProperties = [minecraft_version      : minecraft_version,
                             minecraft_version_range: minecraft_version_range,
                             neo_version            : neo_version,
                             neo_version_range      : neo_version_range,
                             loader_version_range   : loader_version_range,
                             mod_id                 : mod_id,
                             mod_name               : mod_name,
                             mod_license            : mod_license,
                             mod_version            : mod_version,
                             mod_authors            : mod_authors,
                             mod_description        : mod_description]
    inputs.properties replaceProperties
    expand replaceProperties
    from "src/main/templates"
    into "build/generated/sources/modMetadata"
}

// Include the output of "generateModMetadata" as an input directory for the build
// this works with both building through Gradle and the IDE.
sourceSets.main.resources.srcDir generateModMetadata
// To avoid having to run "generateModMetadata" manually, make it run on every project reload
neoForge.ideSyncTask generateModMetadata

// Example configuration to allow publishing using the maven-publish plugin
publishing {
    publications {
        register('mavenJava', MavenPublication) {
            from components.java
        }
    }
    repositories {
        maven {
            url "file://${project.projectDir}/repo"
        }
    }
}

// IDEA no longer automatically downloads sources/javadoc jars for dependencies, so we need to explicitly enable the behavior.
idea {
    module {
        downloadSources = true
        downloadJavadoc = true
    }
}

def generatedDir = "$buildDir/generated/sources/buildInfo/java"

tasks.register('checkUpdateJson') {
    group = 'verification'
    description = 'Verifies that src/main/resources/update.json matches gradle.properties (mod_version, minecraft_version) and promos.'
    doLast {
        def modVer = project.findProperty('mod_version')
        def mcVer = project.findProperty('minecraft_version')
        if (!modVer || !mcVer) {
            throw new GradleException("Missing mod_version or minecraft_version in gradle.properties")
        }
        def f = file('src/main/resources/update.json')
        if (!f.exists()) throw new GradleException("update.json not found at src/main/resources/update.json")
        def json = new groovy.json.JsonSlurper().parse(f)
        def allow = (project.findProperty('allowMismatch') ?: 'false').toString().toBoolean()

        // Check MC bucket exists
        if (!json.containsKey(mcVer)) {
            def msg = "update.json missing Minecraft bucket '${mcVer}'"
            if (allow) { logger.warn(msg) } else { throw new GradleException(msg) }
        } else {
            // Check version entry exists in bucket
            def bucket = json[mcVer] as Map
            if (!bucket.containsKey(modVer)) {
                def msg = "update.json missing version '${modVer}' under bucket '${mcVer}'"
                if (allow) { logger.warn(msg) } else { throw new GradleException(msg) }
            }
        }
        // Check promos
        if (!json.containsKey('promos')) {
            def msg = "update.json missing 'promos' section"
            if (allow) { logger.warn(msg) } else { throw new GradleException(msg) }
        } else {
            def promos = json.promos as Map
            def latestKey = "${mcVer}-latest"
            if (promos[latestKey] != modVer) {
                def msg = "promos['${latestKey}']='${promos[latestKey]}' does not match mod_version='${modVer}'"
                if (allow) { logger.warn(msg) } else { throw new GradleException(msg) }
            }
        }
        println "update.json OK for ${mcVer} / ${modVer}"
    }
}

task uploadToSFTP {
    dependsOn build

    // Capturer les valeurs au moment de la configuration
    def modId = project.mod_id
    def modVersion = project.version
    def buildDir = project.layout.buildDirectory.get().asFile

    doLast {
        def ssh = new SSHClient()

        try {
            println "Connexion au serveur SFTP..."

            // Accepter tous les host keys (pour simplifier)
            ssh.addHostKeyVerifier(new PromiscuousVerifier())

            // Connexion
            ssh.connect("9002.mystrator.com", 2022)
            ssh.authPassword("jlskyzer.6806ca8f", "2317Mon723Feb-MSR")

            println "✓ Connecté au serveur"

            // Utiliser File directement sans file()
            def jarFile = new File(buildDir, "libs/${modId}-${modVersion}.jar")

            if (!jarFile.exists()) {
                throw new GradleException("Le fichier JAR n'existe pas: ${jarFile}")
            }

            println "Upload de ${jarFile.name}..."

            // Upload via SFTP
            ssh.newSFTPClient().withCloseable { sftp ->
                sftp.put(jarFile.absolutePath, "/mods/${jarFile.name}")
            }

            println "✓ Upload réussi : ${jarFile.name}"

        } catch (Exception e) {
            throw new GradleException("Erreur SFTP: ${e.message}", e)
        } finally {
            if (ssh.isConnected()) {
                ssh.disconnect()
            }
        }
    }
}

tasks.register('injectJavadoc') {
    group = 'formatting'
    description = 'Insère des JavaDoc sur toutes les classes et méthodes avec attribution auteur (git blame).'
    doLast {
        def root = file('src/main/java')
        if (!root.exists()) { println "No src/main/java"; return }

        def gitUserName = ("git --no-pager config user.name").execute(null, project.projectDir).text.trim()
        def gitUserEmail = ("git --no-pager config user.email").execute(null, project.projectDir).text.trim()

        int filesChanged = 0
        root.eachFileRecurse { f ->
            if (!f.name.endsWith('.java')) return
            def relPath = root.toPath().relativize(f.toPath()).toString().replace('\\','/')

            // Read content
            def content = f.getText('UTF-8')
            def lines = content.readLines()
            if (lines.isEmpty()) return

            // git blame per file (line aligned)
            def blameProc = new ProcessBuilder(['git','--no-pager','blame','-e','--',f.absolutePath])
                    .directory(project.projectDir)
                    .redirectErrorStream(true)
                    .start()
            blameProc.waitFor()
            def blameOut = blameProc.inputStream.getText('UTF-8')
            def blameLines = blameOut.readLines()
            // Build author by line idx (1-based)
            def authorByLine = [:]
            for (int i=0; i<Math.min(lines.size(), blameLines.size()); i++) {
                def bl = blameLines[i]
                def m = (bl =~ /\(([^<\)]+)?<([^>]+)>\s+\d{4}-\d{2}-\d{2}.*\)/)
                String name = null
                String email = null
                if (m.find()) {
                    name = (m.group(1) ?: '').trim()
                    email = m.group(2)?.trim()
                } else {
                    // not committed yet
                    name = gitUserName
                    email = gitUserEmail
                }
                authorByLine[i+1] = [name:name, email:email]
            }

            // Helper to detect if a block before index already has Javadoc
            def hasJavadocAbove = { int idx ->
                for (int i=idx-1; i>=0 && i>=idx-5; i--) {
                    if (i<0) break
                    def l = lines[i].trim()
                    if (l.isEmpty()) continue
                    if (l.startsWith('/**')) return true
                    if (l.startsWith('/*') || l.startsWith('//')) return false
                    break
                }
                return false
            }

            def sb = new StringBuilder()
            boolean modified = false

            // First pass: add class/interface/enum JavaDoc if missing
            int classLineIdx = -1
            for (int i=0; i<lines.size(); i++) {
                def l = lines[i]
                if (l =~ /\b(class|interface|enum)\b/ && l =~ /\b(public|final|abstract|sealed|non-sealed|record)?\s*(class|interface|enum)\b/) {
                    classLineIdx = i
                    break
                }
            }
            if (classLineIdx > 0 && !hasJavadocAbove(classLineIdx)) {
                def author = authorByLine.get(classLineIdx+1) ?: [name:gitUserName, email:gitUserEmail]
                def classDoc = new StringBuilder()
                classDoc.append('/**\n')
                classDoc.append(' * Classe auto-documentée.\n')
                classDoc.append(" * \n")
                classDoc.append(" * @author ")
                if (author.name) classDoc.append(author.name).append(' ')
                if (author.email) classDoc.append('<').append(author.email).append('>')
                classDoc.append('\n')
                classDoc.append(' */\n')
                lines.add(classLineIdx, classDoc.toString())
                modified = true
                // rebuild authorByLine shift not needed further
            }

            // Re-scan for method declarations and add JavaDoc stubs
            // Simple regex: visibility/modifiers returnType name(params) {  OR end with ; for interface/abstract
            def methodPattern = ~/^\s*(public|protected|private)?\s*(static\s+|final\s+|synchronized\s+|default\s+|abstract\s+)*[\w\<\>\[\]\.,\s]+\s+([a-zA-Z_$][\w$]*)\s*\(([^)]*)\)\s*(throws\s+[\w\.,\s]+)?\s*(\{|;).*/

            for (int i=0; i<lines.size(); i++) {
                def l = lines[i]
                if (!(l ==~ methodPattern)) continue
                if (hasJavadocAbove(i)) continue

                // Extract method name and params
                def m = (l =~ methodPattern)
                if (!m.matches()) continue
                def methodName = m.group(3)
                def params = m.group(4) ?: ''
                // Extract return type by heuristic: take part before name and last token before name not modifier
                String before = l.substring(0, l.indexOf(methodName)).trim()
                // Cleanup generics to avoid confusion
                def retType = 'void'
                try {
                    def tokens = before.split(/\s+/).toList()
                    // remove modifiers
                    def mods = ['public','protected','private','static','final','synchronized','default','abstract'] as Set
                    def filtered = tokens.findAll { !(it in mods) }
                    if (!filtered.isEmpty()) retType = filtered.last()
                } catch (ignored) {}

                def author = authorByLine.get(Math.min(i+1, authorByLine.size())) ?: [name:gitUserName, email:gitUserEmail]
                def doc = new StringBuilder()
                doc.append('/**\n')
                doc.append(' * Documentation automatique.\n')
                if (params.trim()) {
                    // Split params by comma and document last token as name
                    params.split(',').each { p ->
                        def ptrim = p.trim()
                        if (ptrim.isEmpty()) return
                        // Remove annotations
                        ptrim = ptrim.replaceAll(/@[\w.]+\s*/, '')
                        def ptoks = ptrim.split(/\s+/)
                        def pname = ptoks[-1]
                        doc.append(' * @param ').append(pname).append(' ').append('paramètre').append('\n')
                    }
                }
                if (!retType.equals('void')) {
                    doc.append(' * @return résultat\n')
                }
                doc.append(' * @author ')
                if (author.name) doc.append(author.name).append(' ')
                if (author.email) doc.append('<').append(author.email).append('>')
                doc.append('\n')
                doc.append(' */')
                lines.add(i, doc.toString())
                modified = true
                i++ // skip inserted block
            }

            if (modified) {
                f.setText(lines.join(System.lineSeparator()), 'UTF-8')
                filesChanged++
                println "JavaDoc inserted: ${relPath}"
            }
        }
        println "injectJavadoc: ${filesChanged} file(s) updated."
    }
}